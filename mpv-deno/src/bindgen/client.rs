/* automatically generated by rust-bindgen 0.69.3 */

#[doc = " Invalid. Sometimes used for empty values. This is always defined to 0,\n so a normal 0-init of mpv_format (or e.g. mpv_node) is guaranteed to set\n this it to MPV_FORMAT_NONE (which makes some things saner as consequence)."]
pub const mpv_format_MPV_FORMAT_NONE: mpv_format = 0;
#[doc = " The basic type is char*. It returns the raw property string, like\n using ${=property} in input.conf (see input.rst).\n\n NULL isn't an allowed value.\n\n Warning: although the encoding is usually UTF-8, this is not always the\n          case. File tags often store strings in some legacy codepage,\n          and even filenames don't necessarily have to be in UTF-8 (at\n          least on Linux). If you pass the strings to code that requires\n          valid UTF-8, you have to sanitize it in some way.\n          On Windows, filenames are always UTF-8, and libmpv converts\n          between UTF-8 and UTF-16 when using win32 API functions. See\n          the \"Encoding of filenames\" section for details.\n\n Example for reading:\n\n     char *result = NULL;\n     if (mpv_get_property(ctx, \"property\", MPV_FORMAT_STRING, &result) < 0)\n         goto error;\n     printf(\"%s\\n\", result);\n     mpv_free(result);\n\n Or just use mpv_get_property_string().\n\n Example for writing:\n\n     char *value = \"the new value\";\n     // yep, you pass the address to the variable\n     // (needed for symmetry with other types and mpv_get_property)\n     mpv_set_property(ctx, \"property\", MPV_FORMAT_STRING, &value);\n\n Or just use mpv_set_property_string().\n"]
pub const mpv_format_MPV_FORMAT_STRING: mpv_format = 1;
#[doc = " The basic type is char*. It returns the OSD property string, like\n using ${property} in input.conf (see input.rst). In many cases, this\n is the same as the raw string, but in other cases it's formatted for\n display on OSD. It's intended to be human readable. Do not attempt to\n parse these strings.\n\n Only valid when doing read access. The rest works like MPV_FORMAT_STRING."]
pub const mpv_format_MPV_FORMAT_OSD_STRING: mpv_format = 2;
#[doc = " The basic type is int. The only allowed values are 0 (\"no\")\n and 1 (\"yes\").\n\n Example for reading:\n\n     int result;\n     if (mpv_get_property(ctx, \"property\", MPV_FORMAT_FLAG, &result) < 0)\n         goto error;\n     printf(\"%s\\n\", result ? \"true\" : \"false\");\n\n Example for writing:\n\n     int flag = 1;\n     mpv_set_property(ctx, \"property\", MPV_FORMAT_FLAG, &flag);"]
pub const mpv_format_MPV_FORMAT_FLAG: mpv_format = 3;
#[doc = " The basic type is int64_t."]
pub const mpv_format_MPV_FORMAT_INT64: mpv_format = 4;
#[doc = " The basic type is double."]
pub const mpv_format_MPV_FORMAT_DOUBLE: mpv_format = 5;
#[doc = " The type is mpv_node.\n\n For reading, you usually would pass a pointer to a stack-allocated\n mpv_node value to mpv, and when you're done you call\n mpv_free_node_contents(&node).\n You're expected not to write to the data - if you have to, copy it\n first (which you have to do manually).\n\n For writing, you construct your own mpv_node, and pass a pointer to the\n API. The API will never write to your data (and copy it if needed), so\n you're free to use any form of allocation or memory management you like.\n\n Warning: when reading, always check the mpv_node.format member. For\n          example, properties might change their type in future versions\n          of mpv, or sometimes even during runtime.\n\n Example for reading:\n\n     mpv_node result;\n     if (mpv_get_property(ctx, \"property\", MPV_FORMAT_NODE, &result) < 0)\n         goto error;\n     printf(\"format=%d\\n\", (int)result.format);\n     mpv_free_node_contents(&result).\n\n Example for writing:\n\n     mpv_node value;\n     value.format = MPV_FORMAT_STRING;\n     value.u.string = \"hello\";\n     mpv_set_property(ctx, \"property\", MPV_FORMAT_NODE, &value);"]
pub const mpv_format_MPV_FORMAT_NODE: mpv_format = 6;
#[doc = " Used with mpv_node only. Can usually not be used directly."]
pub const mpv_format_MPV_FORMAT_NODE_ARRAY: mpv_format = 7;
#[doc = " See MPV_FORMAT_NODE_ARRAY."]
pub const mpv_format_MPV_FORMAT_NODE_MAP: mpv_format = 8;
#[doc = " A raw, untyped byte array. Only used only with mpv_node, and only in\n some very specific situations. (Some commands use it.)"]
pub const mpv_format_MPV_FORMAT_BYTE_ARRAY: mpv_format = 9;
#[doc = " Data format for options and properties. The API functions to get/set\n properties and options support multiple formats, and this enum describes\n them."]
pub type mpv_format = ::std::os::raw::c_uint;