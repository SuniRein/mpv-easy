/* automatically generated by rust-bindgen 0.69.3 */

#[doc = " Invalid. Sometimes used for empty values. This is always defined to 0,\n so a normal 0-init of mpv_format (or e.g. mpv_node) is guaranteed to set\n this it to MPV_FORMAT_NONE (which makes some things saner as consequence)."]
pub const mpv_format_MPV_FORMAT_NONE: mpv_format = 0;
#[doc = " The basic type is char*. It returns the raw property string, like\n using ${=property} in input.conf (see input.rst).\n\n NULL isn't an allowed value.\n\n Warning: although the encoding is usually UTF-8, this is not always the\n          case. File tags often store strings in some legacy codepage,\n          and even filenames don't necessarily have to be in UTF-8 (at\n          least on Linux). If you pass the strings to code that requires\n          valid UTF-8, you have to sanitize it in some way.\n          On Windows, filenames are always UTF-8, and libmpv converts\n          between UTF-8 and UTF-16 when using win32 API functions. See\n          the \"Encoding of filenames\" section for details.\n\n Example for reading:\n\n     char *result = NULL;\n     if (mpv_get_property(ctx, \"property\", MPV_FORMAT_STRING, &result) < 0)\n         goto error;\n     printf(\"%s\\n\", result);\n     mpv_free(result);\n\n Or just use mpv_get_property_string().\n\n Example for writing:\n\n     char *value = \"the new value\";\n     // yep, you pass the address to the variable\n     // (needed for symmetry with other types and mpv_get_property)\n     mpv_set_property(ctx, \"property\", MPV_FORMAT_STRING, &value);\n\n Or just use mpv_set_property_string().\n"]
pub const mpv_format_MPV_FORMAT_STRING: mpv_format = 1;
#[doc = " The basic type is char*. It returns the OSD property string, like\n using ${property} in input.conf (see input.rst). In many cases, this\n is the same as the raw string, but in other cases it's formatted for\n display on OSD. It's intended to be human readable. Do not attempt to\n parse these strings.\n\n Only valid when doing read access. The rest works like MPV_FORMAT_STRING."]
pub const mpv_format_MPV_FORMAT_OSD_STRING: mpv_format = 2;
#[doc = " The basic type is int. The only allowed values are 0 (\"no\")\n and 1 (\"yes\").\n\n Example for reading:\n\n     int result;\n     if (mpv_get_property(ctx, \"property\", MPV_FORMAT_FLAG, &result) < 0)\n         goto error;\n     printf(\"%s\\n\", result ? \"true\" : \"false\");\n\n Example for writing:\n\n     int flag = 1;\n     mpv_set_property(ctx, \"property\", MPV_FORMAT_FLAG, &flag);"]
pub const mpv_format_MPV_FORMAT_FLAG: mpv_format = 3;
#[doc = " The basic type is int64_t."]
pub const mpv_format_MPV_FORMAT_INT64: mpv_format = 4;
#[doc = " The basic type is double."]
pub const mpv_format_MPV_FORMAT_DOUBLE: mpv_format = 5;
#[doc = " The type is mpv_node.\n\n For reading, you usually would pass a pointer to a stack-allocated\n mpv_node value to mpv, and when you're done you call\n mpv_free_node_contents(&node).\n You're expected not to write to the data - if you have to, copy it\n first (which you have to do manually).\n\n For writing, you construct your own mpv_node, and pass a pointer to the\n API. The API will never write to your data (and copy it if needed), so\n you're free to use any form of allocation or memory management you like.\n\n Warning: when reading, always check the mpv_node.format member. For\n          example, properties might change their type in future versions\n          of mpv, or sometimes even during runtime.\n\n Example for reading:\n\n     mpv_node result;\n     if (mpv_get_property(ctx, \"property\", MPV_FORMAT_NODE, &result) < 0)\n         goto error;\n     printf(\"format=%d\\n\", (int)result.format);\n     mpv_free_node_contents(&result).\n\n Example for writing:\n\n     mpv_node value;\n     value.format = MPV_FORMAT_STRING;\n     value.u.string = \"hello\";\n     mpv_set_property(ctx, \"property\", MPV_FORMAT_NODE, &value);"]
pub const mpv_format_MPV_FORMAT_NODE: mpv_format = 6;
#[doc = " Used with mpv_node only. Can usually not be used directly."]
pub const mpv_format_MPV_FORMAT_NODE_ARRAY: mpv_format = 7;
#[doc = " See MPV_FORMAT_NODE_ARRAY."]
pub const mpv_format_MPV_FORMAT_NODE_MAP: mpv_format = 8;
#[doc = " A raw, untyped byte array. Only used only with mpv_node, and only in\n some very specific situations. (Some commands use it.)"]
pub const mpv_format_MPV_FORMAT_BYTE_ARRAY: mpv_format = 9;
#[doc = " Data format for options and properties. The API functions to get/set\n properties and options support multiple formats, and this enum describes\n them."]
pub type mpv_format = ::std::os::raw::c_uint;

#[doc = " Generic data storage.\n\n If mpv writes this struct (e.g. via mpv_get_property()), you must not change\n the data. In some cases (mpv_get_property()), you have to free it with\n mpv_free_node_contents(). If you fill this struct yourself, you're also\n responsible for freeing it, and you must not call mpv_free_node_contents()."]
#[repr(C)]
#[derive(Copy, Clone )]
pub struct mpv_node {
    pub u: mpv_node__bindgen_ty_1,
    #[doc = " Type of the data stored in this struct. This value rules what members in\n the given union can be accessed. The following formats are currently\n defined to be allowed in mpv_node:\n\n  MPV_FORMAT_STRING       (u.string)\n  MPV_FORMAT_FLAG         (u.flag)\n  MPV_FORMAT_INT64        (u.int64)\n  MPV_FORMAT_DOUBLE       (u.double_)\n  MPV_FORMAT_NODE_ARRAY   (u.list)\n  MPV_FORMAT_NODE_MAP     (u.list)\n  MPV_FORMAT_BYTE_ARRAY   (u.ba)\n  MPV_FORMAT_NONE         (no member)\n\n If you encounter a value you don't know, you must not make any\n assumptions about the contents of union u."]
    pub format: mpv_format,
}

#[repr(C)]
#[derive(Copy, Clone )]
pub union mpv_node__bindgen_ty_1 {
    pub string: *mut ::std::os::raw::c_char,
    #[doc = " valid if format==MPV_FORMAT_STRING"]
    pub flag: ::std::os::raw::c_int,
    #[doc = " valid if format==MPV_FORMAT_FLAG"]
    pub int64: i64,
    #[doc = " valid if format==MPV_FORMAT_INT64"]
    pub double_: f64,
    #[doc = " valid if format==MPV_FORMAT_DOUBLE */\n/**\n valid if format==MPV_FORMAT_NODE_ARRAY\n    or if format==MPV_FORMAT_NODE_MAP"]
    pub list: *mut mpv_node_list,
    #[doc = " valid if format==MPV_FORMAT_BYTE_ARRAY"]
    pub ba: *mut mpv_byte_array,
}
#[doc = " (see mpv_node)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_node_list {
    #[doc = " Number of entries. Negative values are not allowed."]
    pub num: ::std::os::raw::c_int,
    #[doc = " MPV_FORMAT_NODE_ARRAY:\n  values[N] refers to value of the Nth item\n\n MPV_FORMAT_NODE_MAP:\n  values[N] refers to value of the Nth key/value pair\n\n If num > 0, values[0] to values[num-1] (inclusive) are valid.\n Otherwise, this can be NULL."]
    pub values: *mut mpv_node,
    #[doc = " MPV_FORMAT_NODE_ARRAY:\n  unused (typically NULL), access is not allowed\n\n MPV_FORMAT_NODE_MAP:\n  keys[N] refers to key of the Nth key/value pair. If num > 0, keys[0] to\n  keys[num-1] (inclusive) are valid. Otherwise, this can be NULL.\n  The keys are in random order. The only guarantee is that keys[N] belongs\n  to the value values[N]. NULL keys are not allowed."]
    pub keys: *mut *mut ::std::os::raw::c_char,
}

#[doc = " (see mpv_node)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_byte_array {
    #[doc = " Pointer to the data. In what format the data is stored is up to whatever\n uses MPV_FORMAT_BYTE_ARRAY."]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " Size of the data pointed to by ptr."]
    pub size: usize,
}